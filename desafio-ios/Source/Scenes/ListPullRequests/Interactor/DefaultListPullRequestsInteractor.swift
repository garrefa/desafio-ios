//
//  DefaultListPullRequestsInteractor.swift
//  desafio-ios
//
//  Created by Cicero Camargo on 09/04/17.
//  Copyright (c) 2017 Stationfy. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import Foundation

/// Implements the business logic behind the events that come from ListPullRequestsViewController
class DefaultListPullRequestsInteractor: ListPullRequestsInteractor {

    var presenter: ListPullRequestsPresenter!
    var repository: Repository!
    private(set) var pullRequests: [PullRequest] = []
    private let repositoryService: RepositoryService
    private var nextPage: UInt = 0
    private let dispatchQueue = DispatchQueue(label: "ListPullRequestsInteractor Queue")
    
    init(repositoryService: RepositoryService) {
        self.repositoryService = repositoryService
    }
    
    // MARK: - Business logic
    
    func reloadPullRequests() {
        nextPage = 0
        requestNextPageOfPullRequests(shouldAppendResults: false)
        requestPullRequestsCount()
    }
    
    private func requestNextPageOfPullRequests(shouldAppendResults: Bool) {
        repositoryService.pullRequests(
            for: repository,
            filterByState: nil,
            sortBy: nil,
            page: nextPage,
            onCompletion: { pullRequests, hasMorePages in
                self.nextPage += 1
                if shouldAppendResults {
                    self.pullRequests.append(contentsOf: pullRequests)
                } else {
                    self.pullRequests = pullRequests
                }
                self.presenter.presentPullRequests(pullRequests, shouldAppend: shouldAppendResults, hasMore: hasMorePages)
            }, onError: { error in
                self.presenter.presentRequestError(error)
            }
        )
    }
    
    private func requestPullRequestsCount() {
        
        dispatchQueue.async {
            var _openCount: Int?
            var _closedCount: Int?
            
            let semaphore = DispatchSemaphore(value: 0)
            
            self.repositoryService.pullRequestsCount(for: self.repository, filterByState: .open, onCompletion: { openCount in
                _openCount = openCount
                semaphore.signal()
            }, onError: { error in
                semaphore.signal()
            })
            
            self.repositoryService.pullRequestsCount(for: self.repository, filterByState: .closed, onCompletion: { closedCount in
                _closedCount = closedCount
                semaphore.signal()
            }, onError: { error in
                semaphore.signal()
            })
            
            // we call `semaphore.wait()` 2 times here to wait for the two requests above
            semaphore.wait()
            semaphore.wait()
            
            guard let openCount = _openCount, let closedCount = _closedCount else {
                self.presenter.presentPullRequestsCount(.error)
                return
            }
            
            self.presenter.presentPullRequestsCount(.success(openCount: openCount, closedCount: closedCount))
        }
    }
    
    func loadMorePullRequests() {
        guard nextPage > 0 else {
            debugPrint("Warning: trying to load more repos when `nextPage` is 0.")
            reloadPullRequests()
            return
        }
        
        requestNextPageOfPullRequests(shouldAppendResults: true)
    }
}
